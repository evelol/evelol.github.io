“TCP是一种流模式的协议，UDP是一种数据报模式的协议”，这句话相信大家对这句话已经耳熟能详~但是，“流模式”与“数据包模式”在编程的时候有什么区别呢？以下是我的理解，仅供参考！ 1、TCP 
打个比方比喻TCP，你家里有个蓄水池，你可以里面倒水，蓄水池上有个龙头，你可以通过龙头将水池里的水放出来，然后用各种各样的容器装（杯子、矿泉水瓶、锅碗瓢盆）接水。 上面的例子中，往水池里倒几次水和接几次水是没有必然联系的，也就是说你可以只倒一次水，然后分10次接完。另外，水池里的水接多少就会少多少；往里面倒多少水，就会增加多少水，但是不能超过水池的容量，多出的水会溢出。 
结合TCP的概念，水池就好比接收缓存，倒水就相当于发送数据，接水就相当于读取数据。好比你通过TCP连接给另一端发送数据，你只调用了一次write，发送了100个字节，但是对方可以分10次收完，每次10个字节；你也可以调用10次write，每次10个字节，但是对方可以一次就收完。（假设数据都能到达）但是，你发送的数据量不能大于对方的接收缓存（流量控制），如果你硬是要发送过量数据，则对方的缓存满了就会把多出的数据丢弃。 这种情况是设置非阻塞I/O模型，会把内存耗尽，因为socket是存在内核中的。 2、UDP 
UDP和TCP不同，发送端调用了几次write，接收端必须用相同次数的read读完。UPD是基于报文的，在接收的时候，每次最多只能读取一个报文，报文和报文是不会合并的，如果缓冲区小于报文长度，则多出的部分会被丢弃。也就说，如果不指定MSG_PEEK标志，每次读取操作将消耗一个报文。 3、为什么 
其实，这种不同是由TCP和UDP的特性决定的。TCP是面向连接的，也就是说，在连接持续的过程中，socket中收到的数据都是由同一台主机发出的（劫持什么的不考虑），因此，知道保证数据是有序的到达就行了，至于每次读取多少数据自己看着办。 
而UDP是无连接的协议，也就是说，只要知道接收端的IP和端口，且网络是可达的，任何主机都可以向接收端发送数据。这时候，如果一次能读取超过一个报文的数据，则会乱套。比如，主机A向发送了报文P1，主机B发送了报文P2，如果能够读取超过一个报文的数据，那么就会将P1和P2的数据合并在了一起，这样的数据是没有意义的。


结论, 从udp层看,可以发送65507个字节, 
TCP和UDP的原理就不用说了。
TCP：客户端和服务器有一个连接的过程。在发送数据时最多能发送65535个字节，虽然可靠，但是发送的数据被protocol内部分成了几块，分片发送，所以在用TCP传输的时候，在协议制定上要考虑发送数据连续接收，才能保证一个协议帧的数据正确接收。 ------有歧义
UDP：客户端和服务器不需要连接过程。在发送数据时最多能发送65507个字节越63kb，UDP容易丢帧，但是发送的65507个字节不会被内部分片，可以整块发送，所以在制定协议时不用TCP那么复杂，发送和接收都很容易实现。工程应用中比较受欢迎。 ------有歧义, 其实是一定会在ip层分片的.

从理论上来说，UDP数据的总长度为 65535（IP最大长度）-20（IP头）-8（UDP头） = 65507个字节，但大多数系统都达不到这个长度。这一般是受到两个方面的因素限制：
1） 应用程序编程接口限制。一般socket的缓冲区大小是8K，但都提供API来设置缓冲区的大小（SetSockOpt）。一般发送UDP最好不要超过512字节，这样基本可以保证不丢包（因为大部分网络和主机的MTU都大于512）.
2） TCP/IP内核的限制。可能存在一些实现特性使得IP长度不能达到65535。

由于IP能够发送或接收特定长度的数据报并不意味着接收应用程序可以读取该长度的数据。因此，UDP编程接口允许应用程序指定每次返回的最大字节数。如果接收到的数据报长度大于应用程序所能处理的长度，那么会发生什么情况呢？典型的Berkeley版socket API对数据报进行截断，并丢弃任何多余的数据；SVR4下的socket API(包括Solaris 2.x) 并不截断数据报。超出部分数据在后面的读取中返回。它也不通知应用程序从单个UDP数据报中多次进行读取操作；TLI API不丢弃数据。相反，它返回一个标志表明可以获得更多的数据，而应用程序后面的读操作将返回数据报的其余部分。

UDP不会分片，分片是IP层做的事，而且分片重组也是IP层负责的。
如果用UDP发送数据，数据量最好不要太大，应该避免IP层和链路层分包，防止分片丢失，导致整个UDP数据包丢失.



对于以太网环境下UDP传输中的数据包长度问题

　　首先要看TCP/IP协议，涉及到四层：链路层，网络层，传输层，应用层。

　　其中以太网（Ethernet）的数据帧在链路层

　　IP包在网络层

　　TCP或UDP包在传输层

　　TCP或UDP中的数据（Data)在应用层

　　它们的关系是 数据帧｛IP包｛TCP或UDP包｛Data｝｝｝

　　在应用程序中我们用到的Data的长度最大是多少，直接取决于底层的限制。

　　我们从下到上分析一下：

　　在链路层，由以太网的物理特性决定了数据帧的长度为（46＋18）－（1500＋18），其中的18是数据帧的头和尾，也就是说数据帧的内容最大为1500，即MTU（Maximum Transmission Unit）为1500；

　　在网络层，因为IP包的首部要占用20字节，所以这的MTU为1500－20＝1480；

　　在传输层，对于UDP包的首部要占用8字节，所以这的MTU为1480－8＝1472；

　　所以，在应用层，你的Data最大长度为1472。

　　（当我们的UDP包中的数据多于MTU(1472)时，发送方的IP层需要分片fragmentation进行传输，而在接收方IP层则需要进行数据报重组，由于UDP是不可靠的传输协议，如果分片丢失导致重组失败，将导致UDP数据包被丢弃）。

　　从上面的分析来看，在普通的局域网环境下，UDP的数据最大为1472字节最好（避免分片重组）。

　　但在网络编程中，Internet中的路由器可能有设置成不同的值（小于默认值），Internet上的标准MTU值为576，所以Internet的UDP编程时数据长度最好在576－20－8＝548字节以内。

　　MTU对我们的UDP编程很重要，那如何查看路由的MTU值呢？

　　对于windows OS: ping -f -l <data_length> <gateway_IP>

　　如：ping -f -l 1472 192.168.0.1

　　如果提示：Packets needs to be fragmented but DF set.

　　则表明MTU小于1500，不断改小data_length值，可以最终测算出gateway的MTU值；

　　对于linux OS: ping -c <number> -M do -s <data_length> <gateway_IP>

　　如： ping -c 1 -M do -s 1472 192.168.0.1

　　如果提示 Frag needed and DF set……

　　则表明MTU小于1500，可以再测以推算gateway的MTU。

　　当然要修改MTU的值，那就是网管的事了（一般人没这权限呀），我们只能申请加等待了 ^-^ 
