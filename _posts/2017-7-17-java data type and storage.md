转：http://blog.sina.com.cn/s/blog_605f5b 4f0100qt2t.html
Question：Java中的引用的内存分配大小是多少？
如，我声明了一个对象，它在栈中就先有了个空间，（用来放地址引用的），这个空间的大小是多少？
java规范中并没有强行定义虚拟机中任何一种类型在虚拟机中所占用内存的具体大小，但是规范规定了每种类型的取值范围。从这种角度上看，每种类型会有一个最小位宽，或者内存占用大小。
而且java虚拟机规定中，在方法区中所占用的内存大小与在栈帧所占用的内存大小不同，因为在方法区中占用内存以字节为最小单位，但是在战帧中以字为最小单位。如byte类型在方法区中它占用8位，为一个字节，但是在栈帧中以一个字，即32位来处理，其实就是当作一个int类型来处理。
楼主所说的引用类型，其位宽与int型一样，在方法区中它占用32位，4个字节，在栈帧中占用一个字。
但是虚拟机实现者可以扩大这种内存占用量，因为虚拟机规定只要满足取值范围即可，并没有规定非要32位一个字才行。
我觉得java的引用相当于c++的指针,C++的指针是占四个字节，java引用应该也是固定的大小。sunhotspot jvm和ibmjvm中都把引用实现为一个指针，因此在64位平台上，占8个字节，在32位平台上占4个字节。别的jvm不清楚。
1.引用本身的大小和操作系统的位数有关，正如15楼所言在64位平台上，占8个字节，在32位平台上占4个字节，这个应该是很自然的事情，因为32-bit的操作系统，在4G(2^32)的内存空间内找到某个地址，这个地址是用4bytes(32bits)来表示的。
2. 引用本身是保留在栈中的
3. 引用所指的对象，是存放在堆中的
整理自：http://topic.csdn.net/u/20090419/11/b90d9a7b-336e-40e1-afbe-0174ebf1144f.html


关于字节对齐:
因为cpu读取数据是有缓存的,或者说cpu不是按字节读取内存的, 而是按块来读取的, 所以,对于一个地址,读取数据会多读出一定的偏移.
一般预读数据在一个对齐段里比在两个里面要效率高,因为只需寻址一次.
如果是c语言编译出来的二进制文件, 则从编译角度就能发现对cpu字节对齐的优化存在.
而java编译出来得class文件根本不是二进制文件,而仅仅被称为字节码文件,并不是直接映射操作系统的,jvm会对class文件进一步解析.
所以,在class文件里面是感受不到内存字节对齐存在的.
当然,在jvm里面的内存,对于变量的保存,一定会有内存对齐存在的.
这其实是字节码和机器码之间的区别. 其实现在操作系统的程序,都已经隔离直接操作机器码的过程, 所以, 编译出来的是不是机器码也是要看操作系统的实现的. 机器码可是能操作硬件的, 你认为微软会让你实现吗?
32 位 CPU 使用 4 个字节是最为节省的，哪怕你是 1 个 bit 他也是占用 4 个字节。因为 CPU 寻址系统只能 32 位 32 位地寻址。
???32位寻址线, 并不代表4字节存储空间最省啊?  这里讨论的是cpu还是内存呢, 应该就是寻址线的意思吧.
应该说:  32位系统4字节对齐效率最高
为什么呢? 几个理解:
记录一个32位指针地址需要32位存储.
引申: java的引用类型所占用的内存空间?

java规范中并没有强行定义虚拟机中任何一种类型在虚拟机中所占用内存的具体大小，但是规范规定了每种类型的取值范围。从这种角度上看，每种类型会有一个最小位宽，或者内存占用大小。

而且java虚拟机规定中，在方法区中所占用的内存大小与在栈帧所占用的内存大小不同，因为在方法区中占用内存以字节为最小单位，但是在战帧中以字为最小单位。如byte类型在方法区中它占用8位，为一个字节，但是在栈帧中以一个字，即32位来处理，其实就是当作一个int类型来处理。

楼主所说的引用类型，其位宽与int型一样，在方法区中它占用32位，4个字节，在栈帧中占用一个字。
但是虚拟机实现者可以扩大这种内存占用量，因为虚拟机规定只要满足取值范围即可，并没有规定非要32位一个字才行。

我觉得java的引用相当于c++的指针,C++的指针是占四个字节，java引用应该也是固定的大小。sunhotspot jvm和ibmjvm中都把引用实现为一个指针，因此在64位平台上，占8个字节，在32位平台上占4个字节。别的jvm不清楚。

1.引用本身的大小和操作系统的位数有关，正如15楼所言在64位平台上，占8个字节，在32位平台上占4个字节，这个应该是很自然的事情，因为32-bit的操作系统，在4G(2^32)的内存空间内找到某个地址，这个地址是用4bytes(32bits)来表示的。

2. 引用本身是保留在栈中的

3. 引用所指的对象，是存放在堆中的
结论似乎是, jvm中boolean当作int来对待, 当boolean 数组时,当作byte处理.
对于其他基本类型 
关于stream中read一个byte解析成boolean时, 从源码中是用byte解析的.
int ch = in.read();
if (ch < 0)throw new EOFException();
return (ch != 0);
尽管,ch是个int,但这只是表示,读出一个byte,并用int来存储了.
Yes, a byte variable is in fact 4 bytes in memory. However this doesn't hold true for arrays. A byte array of 20 bytes is in fact only 20 bytes in memory. That is because the Java Bytecode Language only knows ints and longs as number types (so it must handle all numbers as either type of both, 4 bytes or 8 bytes), but it knows arrays with every possible number size (so short arrays are in fact two bytes per entry and byte arrays are in fact one byte per entry).


基本类型都存储在栈中吗
---
对楼下这两位的回答表示没有讲到核心，“java，基本类型一定是放在栈中？？这句话对吗？”这句话我明确的肯定的是错的，基本数据类型是放在栈中还是放在堆中，这取决于基本类型在何处声明，下面对数据类型在内存中的存储问题来帮你解释：一：在方法中声明的变，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因<1>在方法中生明的变量可以是基本类型的变量，也可以是引用类型的变量，（1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在方法栈中（2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的》》》二：在类中声明的变量是成员变量，也叫全局变量，放在堆中的，<1>同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量(1)当声明的是基本类型的变量其变量名及其只时放在堆类存中的，（2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。。。。。所说的的可能有些抽象，不懂再问！！！

反编译  C:\java_test>javac Test.java
C:\java_test>javap -verbose Test


1
2
3
4
Integer a= 300;
int b = 300;
System.out.println(a==b);
System.out.println(b==a);

编译-》反编译
Java code
Integer a = Integer.valueOf(300);
int b = 300;
System.out.println(a.intValue() == b);
System.out.println(b == a.intValue());

